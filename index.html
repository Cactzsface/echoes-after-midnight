<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Echoes After Midnight - Metroidvania 2.0</title>
<style>
body { margin:0; background:#0a0a14; overflow:hidden; }
canvas { display:block; margin:auto; background:#0f1020; }
</style>
</head>
<body>

<canvas id="game" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let keys = {};

const worldRooms = ["hub","dashRoom","boss1","phaseRoom","comboRoom","boss2"];

const rooms = {
  hub: { exits:{down:"dashRoom"}, gates:[] },
  dashRoom: { exits:{up:"hub",right:"boss1"}, gates:[{x:360,y:250,w:80,h:20,type:"dash"}] },
  boss1: { exits:{left:"dashRoom",down:"phaseRoom"}, boss:"chaser" },
  phaseRoom: { exits:{up:"boss1",right:"comboRoom"}, gates:[{x:700,y:200,w:20,h:200,type:"phase"}] },
  comboRoom: {
    exits:{left:"phaseRoom",right:"boss2"},
    gates:[{x:200,y:100,w:100,h:20,type:"combo"}], // needs dash + phase
    teleport:[{x:650,y:400,w:40,h:40,target:"boss2"}] // teleport shortcut
  },
  boss2: { exits:{left:"comboRoom"}, boss:"warden" }
};

const player = {
  x: 380, y: 280, size: 40,
  speed: 4,
  health: 100,
  memories: 0,
  dash: false,
  phase: false
};

let room = "hub";
let boss = null;
let discoveredRooms = new Set([room]);

document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// ------------------- UTILS -------------------
function collide(a,b){
  return a.x < b.x+b.w && a.x+a.size>b.x && a.y<b.y+b.h && a.y+a.size>b.y;
}

// ------------------- SAVE SYSTEM -------------------
function saveGame() {
  const saveData = {
    room,
    x: player.x,
    y: player.y,
    health: player.health,
    memories: player.memories,
    dash: player.dash,
    phase: player.phase,
    discoveredRooms: Array.from(discoveredRooms)
  };
  localStorage.setItem("echoesSave", JSON.stringify(saveData));
}

function loadGame() {
  const data = JSON.parse(localStorage.getItem("echoesSave"));
  if (data) {
    room = data.room;
    player.x = data.x;
    player.y = data.y;
    player.health = data.health;
    player.memories = data.memories;
    player.dash = data.dash;
    player.phase = data.phase;
    discoveredRooms = new Set(data.discoveredRooms);
  }
}

// Auto-load
loadGame();

// ------------------- GAME MECHANICS -------------------
function spawnBoss(type) {
  if (!type) return;
  boss = {
    x: 350, y: 100, size: 80,
    health: type==="chaser"?120:200,
    speed: type==="chaser"?2.5:1.2,
    type
  };
}

function changeRoom(newRoom) {
  room = newRoom;
  player.x = 380;
  player.y = 280;
  boss = null;
  discoveredRooms.add(newRoom);
  saveGame();
}

function update() {
  let speed = player.speed;
  if (keys.shift && player.dash) speed = 8;

  if (keys.w) player.y -= speed;
  if (keys.s) player.y += speed;
  if (keys.a) player.x -= speed;
  if (keys.d) player.x += speed;

  // Room bounds & exits
  if (player.x < 0 && rooms[room].exits.left) changeRoom(rooms[room].exits.left);
  if (player.x > 760 && rooms[room].exits.right) changeRoom(rooms[room].exits.right);
  if (player.y < 0 && rooms[room].exits.up) changeRoom(rooms[room].exits.up);
  if (player.y > 560 && rooms[room].exits.down) changeRoom(rooms[room].exits.down);

  // Gates
  (rooms[room].gates||[]).forEach(g=>{
    if (collide(player,g)){
      if (g.type==="dash" && !player.dash || g.type==="phase" && !player.phase || g.type==="combo" && !(player.dash && player.phase)){
        player.x -= speed; player.y -= speed;
      }
    }
  });

  // Teleports
  (rooms[room].teleport||[]).forEach(t=>{
    if (collide(player,t)) changeRoom(t.target);
  });

  // Boss
  if (rooms[room].boss && !boss) spawnBoss(rooms[room].boss);

  if (boss) {
    let dx = player.x - boss.x;
    let dy = player.y - boss.y;
    let d = Math.hypot(dx,dy);
    boss.x += (dx/d) * boss.speed;
    boss.y += (dy/d) * boss.speed;

    if (Math.hypot(dx,dy) < 60 && keys[" "]) boss.health -= 2;
    if (Math.hypot(dx,dy) < 60) player.health -= 0.4;

    if (boss.health <= 0){
      if (boss.type==="chaser") player.dash = true;
      if (boss.type==="warden") player.phase = true;
      boss = null;
      saveGame();
    }
  }
}

// ------------------- DRAW -------------------
function draw() {
  ctx.clearRect(0,0,800,600);

  // Player
  ctx.fillStyle="#66ccff";
  ctx.fillRect(player.x,player.y,40,40);

  // Gates
  (rooms[room].gates||[]).forEach(g=>{
    ctx.fillStyle = g.type==="dash"?"#ff4444":g.type==="phase"?"#4444ff":"#ff44ff";
    ctx.fillRect(g.x,g.y,g.w,g.h);
  });

  // Teleports
  (rooms[room].teleport||[]).forEach(t=>{
    ctx.fillStyle="#44ff44";
    ctx.fillRect(t.x,t.y,t.w,t.h);
  });

  // Boss
  if (boss) { ctx.fillStyle="#ff8888"; ctx.fillRect(boss.x,boss.y,boss.size,boss.size); }

  // Mini-map
  const mapX = 600, mapY = 10, size = 30;
  worldRooms.forEach((r,i)=>{
    ctx.fillStyle = discoveredRooms.has(r)?(r===room?"#66ff66":"#888888"):"#222222";
    ctx.fillRect(mapX + i*35, mapY, size, size);
  });

  // UI
  ctx.fillStyle="white";
  ctx.font="18px Arial";
  ctx.fillText("Room: "+room,10,25);
  ctx.fillText("Health: "+Math.floor(player.health),10,50);
  ctx.fillText("Memories: "+player.memories,10,75);
  ctx.fillText("Dash: "+player.dash+" | Phase: "+player.phase,10,100);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
